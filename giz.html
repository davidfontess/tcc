<!DOCTYPE html>
<html>
<head>
    <title>Desenho com EaselJS</title>
    <script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>
</head>
<body>
    <canvas id="demoCanvas" width="400" height="400"></canvas>
    <script>
        const canvasSize = 400;
        const coordMax = 10;
        const step = canvasSize / (2 * coordMax);

        const stage = new createjs.Stage("demoCanvas");

        // Função para converter coordenadas do sistema cartesiano para o canvas
        const converterCoordenadas = (x, y) => [
            canvasSize / 2 + x * step,
            canvasSize / 2 - y * step
        ];

        // Função para desenhar o plano cartesiano
        const desenharPlanoCartesiano = () => {
            const eixo = new createjs.Shape();
            eixo.graphics.setStrokeStyle(1).beginStroke("black");

            // Eixo X
            eixo.graphics.moveTo(0, canvasSize / 2).lineTo(canvasSize, canvasSize / 2);
            // Eixo Y
            eixo.graphics.moveTo(canvasSize / 2, 0).lineTo(canvasSize / 2, canvasSize);

            // Linhas de grade
            for (let i = -coordMax; i <= coordMax; i++) {
                if (i !== 0) {
                    let [x, y] = converterCoordenadas(i, 0);
                    eixo.graphics.setStrokeStyle(0.3).moveTo(x, 0).lineTo(x, canvasSize);
                    [x, y] = converterCoordenadas(0, i);
                    eixo.graphics.moveTo(0, y).lineTo(canvasSize, y);
                }
            }

            stage.addChild(eixo);

            // Números nos eixos
            const textFormat = "12px Arial";
            for (let i = -coordMax+1; i < coordMax; i++) {
                if (i !== 0) {
                    let [x, y] = converterCoordenadas(i, -0.3);
                    let textX = new createjs.Text(i, textFormat, "black");
                    textX.x = x - 6;
                    textX.y = y;
                    stage.addChild(textX);

                    [x, y] = converterCoordenadas(0.3, i);
                    let textY = new createjs.Text(i, textFormat, "black");
                    textY.x = x;
                    textY.y = y - 6;
                    stage.addChild(textY);
                }
            }
        };

        // Classe base para figuras
        class Figura {
            constructor(cor = "black") {
                this.x = 0;
                this.y = 0;
                this.cor = cor;
                this.angulo = 0;
            }
            clone() {
                return Object.assign(Object.create(Object.getPrototypeOf(this)), this);
            }
        }

        // Classe para retângulos
        class Retangulo extends Figura {
            constructor(base, altura, cor = "black") {
                super(cor);
                this.base = base;
                this.altura = altura;
            }
        }

        // Classe para círculos
        class Circulo extends Figura {
            constructor(raio, cor = "black") {
                super(cor);
                this.raio = raio;
            }
        }

        class PlanoCartesiano extends Figura {
            constructor(cor = "gray") {
                super(cor);
            }
        }

        class Linha extends Figura {
            constructor(x2, y2, cor = "black") {
                super(cor);
                this.x2 = x2;
                this.y2 = y2;
            }
        }

        class Polilinha extends Figura {
            constructor(pontos, cor = "black") {
                super(cor);
                this.pontos = pontos;
            }
        }

        class Poligono extends Figura {
            constructor(pontos, cor = "black") {
                super(cor);
                this.pontos = pontos;
            }
        }

        const retangulo = (largura, altura) => {
          return new Retangulo(largura, altura);
        };

        /*
        const criarCirculo = (raio) => {
          return new Circulo(raio);
        };

        const criarPoligono = (pontos) => {
            return new Poligono(pontos);
        };

        const criarLinha = (x1, y1, x2, y2) => {
            return new Linha(x1,y1,x2,y2);
        };

        const colorirFundo = (cor) => {
          const fundo = new createjs.Shape();
          fundo.graphics.beginFill(traduzirCor(cor)).drawRect(0, 0, canvasSize, canvasSize);
          stage.addChild(fundo);
        };
        */

        class Texto extends Figura {
            constructor(conteudo, tamanho = "12px", cor = "black") {
                super(cor);
                this.conteudo = conteudo;
                this.tamanho = tamanho;
            }
        }

        // Classe para figuras compostas
        class FiguraComposta extends Figura {
            constructor(figuras = []) {
                super();
                this.figuras = figuras;
            }
        }

        // Função para compor figuras
        const comporFiguras = (figs) => new FiguraComposta(figs);

        // Função para transladar figuras
        const transladar = (fig, dx, dy) => {
            if (fig instanceof FiguraComposta) {
                return new FiguraComposta(fig.figuras.map(f => transladar(f, dx, dy)));
            } else {
                let novaFigura = fig.clone();
                novaFigura.x += dx;
                novaFigura.y += dy;
                return novaFigura;
            }
        };

        const rotacionar = (figura, angulo) => {
            if (figura instanceof FiguraComposta) {
                return new FiguraComposta(figura.figuras.map(f => rotacionar(f, angulo)));
            } else {
                let novaFigura = figura.clone();
                novaFigura.angulo += angulo; // Adiciona o ângulo à rotação atual
                return novaFigura;
            }
        };

        // Função para colorir figuras
        /* TODO: fazer algo parecido com transladar para figuraComposta */
        const colorir = (fig, cor) => {
            let novaFigura = fig.clone();
            novaFigura.cor = cor;
            return novaFigura;
        };

        const calcularCentro = (pontos) => {
            let somaX = 0, somaY = 0;
            pontos.forEach(p => {
                somaX += p[0];
                somaY += p[1];
            });
            return [somaX / pontos.length, somaY / pontos.length];
        };

        // Função para traduzir cores do português para o inglês
        const traduzirCor = (cor) => {
            const cores = {
                "preto": "black",
                "branco": "white",
                "vermelho": "red",
                "verde": "green",
                "azul": "blue",
                "amarelo": "yellow",
                "rosa": "pink",
                "roxo": "purple",
                "laranja": "orange",
                "cinza": "gray",
                "marrom": "brown"
                // Adicione outras cores conforme necessário
            };
            return cores[cor.toLowerCase()] || cor;
        };

        // Método desenhar atualizado para centralizar figuras na origem (0,0)
        const desenhar = (figura, stage) => {
            if (figura instanceof FiguraComposta) {
                figura.figuras.forEach(f => desenhar(f, stage));
            } else {
                let shape = new createjs.Shape();
                if (figura instanceof Retangulo) {
                    shape.graphics.beginFill(traduzirCor(figura.cor));
                    let [x, y] = converterCoordenadas(figura.x, figura.y);
                    shape.graphics.drawRect(
                        -figura.base * step / 2,
                        -figura.altura * step / 2,
                        figura.base * step,
                        figura.altura * step
                    );
                    shape.x = x;
                    shape.y = y;
                    shape.graphics.endFill();
                } else if (figura instanceof Circulo) {
                    shape.graphics.beginFill(traduzirCor(figura.cor));
                    let [x, y] = converterCoordenadas(figura.x, figura.y);
                    shape.graphics.drawCircle(0, 0, figura.raio * step);
                    shape.x = x;
                    shape.y = y;
                    shape.graphics.endFill();
                } else if (figura instanceof Linha) {
                    let [x1, y1] = converterCoordenadas(figura.x, figura.y);
                    let [x2, y2] = converterCoordenadas(figura.x2, figura.y2);
                    shape.graphics.setStrokeStyle(1).beginStroke(traduzirCor(figura.cor));
                    shape.graphics.moveTo(x1, y1).lineTo(x2, y2);
                    shape.graphics.endStroke();
                } else if (figura instanceof Polilinha) {
                    shape.graphics.setStrokeStyle(1).beginStroke(traduzirCor(figura.cor));
                    shape.graphics.moveTo(...converterCoordenadas(...figura.pontos[0]));
                    figura.pontos.slice(1).forEach(p => shape.graphics.lineTo(...converterCoordenadas(...p)));
                    const centro = calcularCentro(figura.pontos);
                    //shape.regX = centro[0] * step; // Ajusta o centro de rotação
                    //shape.regY = centro[1] * step; // Ajusta o centro de rotação
                    shape.graphics.endStroke();
                } else if (figura instanceof Poligono) {
                    shape.graphics.beginFill(traduzirCor(figura.cor));
                    shape.graphics.setStrokeStyle(1).beginStroke(traduzirCor(figura.cor));
                    shape.graphics.moveTo(...converterCoordenadas(...figura.pontos[0]));
                    figura.pontos.slice(1).forEach(p => shape.graphics.lineTo(...converterCoordenadas(...p)));
                    shape.graphics.lineTo(...converterCoordenadas(...figura.pontos[0]));
                    const centro = calcularCentro(figura.pontos);
                    //shape.regX = centro[0] * step; // Ajusta o centro de rotação
                    //shape.regY = centro[1] * step; // Ajusta o centro de rotação
                    shape.graphics.endFill();
                    shape.graphics.endStroke();
                } else if (figura instanceof Texto) {
                    let [x, y] = converterCoordenadas(figura.x, figura.y);
                    let text = new createjs.Text(figura.conteudo, figura.tamanho + " Arial", figura.cor);
                    text.x = x;
                    text.y = y;
                    stage.addChild(text);
                    stage.update();
                    return;
                }

                // Aplica a rotação à figura
                shape.rotation = figura.angulo; // Define o ângulo de rotação
                stage.addChild(shape);
            }
            stage.update();
        };


        // Desenhar o plano cartesiano
        desenharPlanoCartesiano();

        // Exemplo de uso
        const janela = transladar(colorir(new Circulo(2), "azul"),5,5);
        const parede = transladar(rotacionar(colorir(new Retangulo(2, 2), "amarelo"),45), 5,-5);
        const parede2 = retangulo(3,1); // USANDO FUNÇÃO, EM VEZ DE OBJ DIRETAMENTE
        const linha = new Linha(-5, 5, "red");
        const polilinha = new Polilinha([[-3, -3], [0, 3], [3, -3]], "green");
        const poligono = new Poligono([[-5, -5], [-2, -2], [0, -5]], "purple");
        const poligonoRotacionado = rotacionar(poligono, 30);
        const texto = new Texto("Olá, mundo!", "16px", "black");
        const casa = comporFiguras([linha, poligono, polilinha, janela, parede, parede2, texto]);

        desenhar(casa, stage);
    </script>
</body>
</html>
